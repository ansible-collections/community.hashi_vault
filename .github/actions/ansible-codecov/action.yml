---
name: Upload Ansible coverage reports with flags
description: Does separate codecov uploads with flags taken from ansible-test's --group-by options
inputs:
  additional-flags:
    description: Additional custom flags (comma separated) to be added to all reports.
    required: false
  directory-flag-pattern:
    description: |
      A pattern to infer flags from directory names. For example this pattern:
        {ansible-%}=python-{py%}={%}
      applied to a directory name like:
        stable-2.11=python-3.9=rando
      Results in the flags:
        ansible-stable-2.11,py3.9,rando
    required: false
  file-flag-pattern:
    description: |
      A pattern to infer flags from coverage reports. For example the default pattern:
        coverage={%}={%}={%}={%}.xml
      applied to a file name like:
        coverage=integration=lookup_some_plugin=docker-default=python-3.9.xml
      Results in the flags:
        integration,target_lookup_some_plugin,env_docker-default,py3.9
    required: false
    default: coverage={%}={target_%}={env_%}=python-{py%}.xml
  directory:
    description: The directory to scan recursively. Defaults to current working directory.
    required: false
runs:
  using: composite
  steps:
    - name: Download and verify codecov uploader
      shell: bash
      run: |
        echo "::group::Installing codecov uploader"

        mkdir -p /tmp/ccbin
        cd /tmp/ccbin

        echo "/tmp/ccbin" >> ${GITHUB_PATH}

        if command -v codecov ; then
            ./codecov --version
        else
            curl https://keybase.io/codecovsecurity/pgp_keys.asc | gpg --import # One-time step
            curl -Os https://uploader.codecov.io/latest/linux/codecov
            curl -Os https://uploader.codecov.io/latest/linux/codecov.SHA256SUM
            curl -Os https://uploader.codecov.io/latest/linux/codecov.SHA256SUM.sig
            gpg --verify codecov.SHA256SUM.sig codecov.SHA256SUM
            shasum -a 256 -c codecov.SHA256SUM
            chmod +x codecov

            ./codecov --version
        fi

        echo "::endgroup::"

    - shell: python
      env:
        PYTHONUNBUFFERED: '1'
      run: |
        import subprocess
        import re
        from pathlib import Path

        def get_flags(pattern, input):
            patpat = r'\{(?P<pat>[^\}]+)\}'

            pats = re.findall(patpat, pattern)

            matcher = re.sub(patpat, r'(.*?)', pattern)

            match = re.search(matcher, input)

            if match:
                return [pats[i].replace('%', result) for i, result in enumerate(match.groups())]

            return None

        additional_flags = r'${{ inputs.additional-flags }}'
        file_flag_pattern = r'${{ inputs.file-flag-pattern }}'
        directory_flag_pattern = r'${{ inputs.directory-flag-pattern }}'
        directory = r'${{ inputs.directory }}'

        extra_flags = additional_flags.split(',') if additional_flags else []

        flags = {}

        directory = Path(directory) if directory else Path.cwd()

        for f in directory.rglob('*'):
            if f.is_file():
                iflags = set()
                if directory_flag_pattern:
                    for part in f.parent.parts:
                        dflags = get_flags(directory_flag_pattern, part)
                        if dflags:
                            iflags.update(dflags)

                fflags = get_flags(file_flag_pattern, str(f.name))
                if fflags:
                    iflags.update(fflags)

                for flag in iflags:
                    flags.setdefault(flag, []).append(str(f.resolve()))

        logextra = ' (+%r)' % extra_flags if extra_flags else ''

        for flag, files in flags.items():
            allflags = ','.join([flag] + extra_flags)
            # allfiles = ','.join(files)
            cmd = ['codecov', '-F', allflags]
            [cmd.extend(['-f', file]) for file in files]

            print('::group::Flag: %s%s' % (flag, logextra))

            # os.system('codecov -F "%s" -f "%s"' % (allflags, allfiles))
            print('Executing: %r' % cmd)
            subprocess.run(cmd, stderr=subprocess.STDOUT, check=True)

            # with subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT) as p:
            #     for line in iter(p.stdout.readline, b''):
            #         print(line)

            print('::endgroup::')
